<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="blockly-import.html">
<link rel="import" href="toolbox.html" id="toolboxImport">
<dom-module id="code-it-blockly">
  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        height: 100%;
      }
      #blocklyDiv, #codeDiv {
        height: 99%;
        width: 100%;
        position: absolute;
      }
      paper-tab {
        background-color: #9e9e9e;
      }
      .outer {
        position: absolute;
        height: 100%;
        width: 100%;
      }
      .tabContent {
        position: relative;
      }
      textarea {
        width: 100%;
        height: 100%;
        padding: 10px;
        border: none;
        box-sizing: border-box; 
      }
      paper-button {
        @apply(--paper-font-button);
        border-radius: 2px;
        padding: 6px 16px;
        height: 36px;
      }
      .programName {
        max-width: 500px;
      }
      .runstop {
        position: relative;
        top: 16px;
        color: #fff;
      }
      .isrunning {
        background-color: #D32F2F;
      }
      .notrunning {
        background-color: #388E3C;
      }
    </style>
    <div class="outer layout vertical">
      <div class="controls layout horizontal">
        <paper-input label="Program name" class="programName flex" value="{{name}}" on-change="onNameChange"></paper-input>
        <paper-button raised class$="runstop {{runState}}" on-tap="handleRunStop">
          <template is="dom-if" if$="{{!isRunning}}">
            <iron-icon icon="av:play-arrow"></iron-icon> Run
          </template>
          <template is="dom-if" if$="{{isRunning}}">
            <iron-icon icon="av:stop"></iron-icon> Stop
          </template>
        </paper-button>
      </div>
      <paper-tabs noink selected="{{selected}}" id="codeTabs">
        <paper-tab>Program</paper-tab>
        <paper-tab id="codeTab">Code</paper-tab>
      </paper-tabs>
      <iron-pages selected="{{selected}}" on-iron-select="handleTab" class="tabContent flex">
        <section>
          <div id="blocklyDiv"></div>
        </section>
        <section>
          <div id="codeDiv">
            <textarea disabled id="code">{{code}}</textarea>
          </div>
        </section>
      </iron-pages>
    </div>
  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'code-it-blockly',

      properties: {
        injected: {
          type: Boolean,
          value: false,
        },
        selected: {
          type: Number,
        },
        code: String,
        runState: {
          type: String,
          value: 'notrunning', // Either 'isrunning' or 'notrunning'
          computed: '_computeRunState(isRunning)',
        },
        programId: {
          type: String,
          value: '',
          observer: '_handleProgramIdChanged',
        },
        name: String,
        xml: String,
        isRunning: {
          type: Boolean,
          value: false,
        }
      },

      ready: function() {
        this.isRunningTopic = new ROSLIB.Topic({
          ros: ROS,
          name: '/code_it/is_program_running',
          type: 'std_msgs/Bool'
        });
        var that = this;
        this.isRunningTopic.subscribe(function(msg) {
          that._handleIsRunningMsg(that, msg);
        });
      },

      _handleIsRunningMsg: function(that, msg) {
        that.isRunning = msg.data;
      },

      _handleProgramIdChanged: function() {
        if (!this.programId) {
          return;
        }
        var that = this;
        var getClient = new ROSLIB.Service({
          ros: ROS,
          name: '/code_it/get_program',
          serviceType: 'code_it/GetProgram'
        });
        var request = new ROSLIB.ServiceRequest({
          program_id: that.programId
        });
        getClient.callService(request, function(result) {
          that.name = result.program.name;
          that.xml = result.program.xml;
          var xmlDom = Blockly.Xml.textToDom(that.xml);

          // Blockly loads toolbox asynchronously.
          // We also load the program asynchronously.
          // So, we need to wait for the workspace first.
          function waitForWorkspace() {
            var workspace = Blockly.getMainWorkspace();
            if (workspace) {
              workspace.clear();
              Blockly.Xml.domToWorkspace(workspace, xmlDom);
            } else {
              setTimeout(waitForWorkspace, 500);
            }
          }
          waitForWorkspace();
        }); 
      },

      handleTab: function(evt) {
        if (this.selected === 0) {
          this.inject();
          this.showExtraDivs();
        } else {
          this.hideExtraDivs();
        }
        evt.stopPropagation(); // TODO(jstn): this doesn't stop propagation.
      },

      hideExtraDivs: function() {
        var toolboxDiv = document.querySelector('.blocklyToolboxDiv');
        var widgetDiv = document.querySelector('.blocklyWidgetDiv');
        var tooltipDiv = document.querySelector('.blocklyTooltipDiv');
        this.hideExtraDiv(toolboxDiv);
        this.hideExtraDiv(widgetDiv);
        this.hideExtraDiv(tooltipDiv);
      },

      showExtraDivs: function() {
        var toolboxDiv = document.querySelector('.blocklyToolboxDiv');
        var widgetDiv = document.querySelector('.blocklyWidgetDiv');
        var tooltipDiv = document.querySelector('.blocklyTooltipDiv');
        this.showExtraDiv(toolboxDiv);
        this.showExtraDiv(widgetDiv);
        this.showExtraDiv(tooltipDiv);
      },

      hideExtraDiv: function(div) {
        if (div) {
          div.style.display = 'none';
        }
      },

      showExtraDiv: function(div) {
        if (div) {
          div.style.display = '';
        }
      },

      inject: function() {
        if (!this.injected) {
          this.importHref('elements/code-it-blockly/toolbox.html', function(e) {
            var toolbox = e.target.import.querySelector('#toolbox');
            var blocklyDiv = this.$.blocklyDiv;
            var workspace = Blockly.inject(blocklyDiv, {toolbox: toolbox, zoom: {
              controls: true,
              wheel: true,
              startScale: 1.0,
              maxScale: 2,
              minScale: 0.3,
              scaleSpeed: 1.2}
            });
            var that = this;
            var updateCode = function() {
              var code = Blockly.JavaScript.workspaceToCode(workspace);
              that.code = code;
            };
            workspace.addChangeListener(updateCode);
            workspace.addChangeListener(function() {
              that.onProgramChange(that);
            });
          });
          this.injected = true;
        }
      },

      onNameChange: function() {
        var that = this;
        var updateClient = new ROSLIB.Service({
          ros: ROS,
          name: '/code_it/update_program',
          serviceType: 'code_it/UpdateProgram'
        });
        var request = new ROSLIB.ServiceRequest({
          program: {
            program_id: that.programId,
            name: that.name,
          }
        });
        updateClient.callService(request, function(result) {
          that.program = result.program;
        }); 
      },

      onProgramChange: function(that) {
        var workspace = Blockly.getMainWorkspace();
        var xml = Blockly.Xml.workspaceToDom(workspace);
        var xmlText = Blockly.Xml.domToText(xml);
        var updateClient = new ROSLIB.Service({
          ros: ROS,
          name: '/code_it/update_program',
          serviceType: 'code_it/UpdateProgram'
        });
        var request = new ROSLIB.ServiceRequest({
          program: {
            program_id: that.programId,
            xml: xmlText,
          }
        });
        updateClient.callService(request, function() {}); 
      },

      _computeRunState: function(isRunning) {
        if (isRunning) {
          return 'isrunning';
        } else {
          return 'notrunning';
        }
      },

      handleRunStop: function() {
        var that = this;
        var runAction = new ROSLIB.ActionClient({
          ros: ROS,
          serverName: '/run_program',
          actionName: 'code_it/RunProgramAction'
        });

        if (!this.isRunning) {
          var goal = new ROSLIB.Goal({
            actionClient: runAction,
            goalMessage: {
              program: that.code
            }
          });

          goal.on('feedback', function(feedback) {
            console.log('Feedback: ' + feedback.block_id);
          });
          goal.on('result', function(result) {
            console.log(result);
          });

          goal.send();
          console.log('Running program: ' + that.code);
        } else {
          runAction.cancel();
        }
      },
    });
  })();
  </script>
</dom-module>
