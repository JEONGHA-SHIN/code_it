<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-toast/paper-toast.html">
<link rel="import" href="blockly-import.html">
<link rel="stylesheet" href="https://codemirror.net/lib/codemirror.css">
<script src="https://codemirror.net/lib/codemirror.js"></script>
<script src="https://codemirror.net/mode/javascript/javascript.js"></script>
<dom-module id="code-it-blockly">
  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        height: 100%;
      }
      #blocklyDiv, {
        height: 99%;
        width: 100%;
        position: absolute;
      }
      paper-tab {
        background-color: #9e9e9e;
      }
      .outer {
        position: absolute;
        height: 100%;
        width: 100%;
      }
      .tabContent {
        position: relative;
      }
      textarea {
        width: 100%;
        height: 100%;
        padding: 10px;
      
        box-sizing: border-box; 
      }
      paper-button {
        @apply(--paper-font-button);
        border-radius: 2px;
        padding: 6px 16px;
        height: 36px;
      }
      .programName {
        max-width: 500px;
      }
      .runstop {
        position: relative;
        top: 16px;
        color: #fff;
      }
      .isrunning {
        background-color: #D32F2F;
      }
      .notrunning {
        background-color: #388E3C;
      }
      .mh60 {
      	min-height: 60px;
      }
    </style>
    <code-it-blockly-toolbox id="toolboxElement"></code-it-blockly-toolbox>
    <div class="outer layout vertical">
      <div class="controls layout horizontal mh60">
        <paper-input label="Program name" class="programName flex" value="{{name}}" on-change="onNameChange"></paper-input>
        <paper-button raised class$="runstop {{runState}}" on-tap="handleRunStop">
          <template is="dom-if" if$="{{!isRunning}}">
            <iron-icon icon="av:play-arrow"></iron-icon> Run
          </template>
          <template is="dom-if" if$="{{isRunning}}">
            <iron-icon icon="av:stop"></iron-icon> Stop
          </template>
        </paper-button>
      </div>
          <div id="codeDiv">
            <textarea id="code">{{code}}</textarea>
	    <script> 
		     //myCodeMirror.id = "codeMirror";	
            </script>
          </div>
    </div>
    <paper-toast id="toast"></paper-toast>
  </template>
  <script>
 // var myCodeMirror = CodeMirror.fromTextArea(document.getElementById('code'));
  (function() {
    'use strict';

    Polymer({
      is: 'code-it-blockly',

      properties: {
        injected: {
          type: Boolean,
          value: false,
        },
        selected: {
          type: Number,
        },
        code: String,
        runState: {
          type: String,
          value: 'notrunning', // Either 'isrunning' or 'notrunning'
          computed: '_computeRunState(isRunning)',
        },
        programId: {
          type: String,
          value: '',
          observer: '_handleProgramIdChanged',
        },
        name: String,
        xml: String,
        isRunning: {
          type: Boolean,
          value: false,
        },
        _errorTopic: Object,
      },

      ready: function() {
	this.myCodeMirror = CodeMirror.fromTextArea(this.$.code, {
			lineNumbers: true,
			// onChange: function() {console.log('onchange'); this.onProgramChange(this);},
			// saveFunction: this.onProgramChange,
			gutter: true,
			reindentOnLoad: true,
			showCursorWhenSelecting: true,	
                	value: "\n\n\n\n\n\n\n\n\n"
		     });
	var codeMirrorDomObj = this.getElementsByClassName("CodeMirror")[0]; // get CodeMirror dom elm
	codeMirrorDomObj.style.border = "1px solid gray";
	codeMirrorDomObj.style.height = "99%";
        
	that = this;
	this.myCodeMirror.on("change", function() {console.log("test"); that.onProgramChange(this)});
        this.isRunningTopic = new ROSLIB.Topic({
          ros: ROS,
          name: '/code_it/is_program_running',
          type: 'std_msgs/Bool'
        });
        var that = this;
        this.isRunningTopic.subscribe(function(msg) {
          that._handleIsRunningMsg(that, msg);
        });

        this._errorTopic = new ROSLIB.Topic({
          ros: ROS,
          name: '/code_it/errors',
          type: 'std_msgs/String'
        });
        this._errorTopic.subscribe(function(msg) {
          that.$.toast.text = msg.data;
          that.$.toast.show();
        });
      },

      _handleIsRunningMsg: function(that, msg) {
        that.isRunning = msg.data;
      },

      _handleProgramIdChanged: function() {
        if (!this.programId) {
          return;
        }
        var that = this;
        var getClient = new ROSLIB.Service({
          ros: ROS,
          name: '/code_it/get_program',
          serviceType: 'code_it_msgs/GetProgram'
        });
        var request = new ROSLIB.ServiceRequest({
          program_id: that.programId
        });
        getClient.callService(request, function(result) {
          that.name = result.program.name;
          that.xml = result.program.xml;
          that.myCodeMirror.setValue(that.xml);
          // hack to make xml be the js code 
          // var xmlDom = Blockly.Xml.textToDom(that.xml);

          // var workspace = Blockly.getMainWorkspace();
          // workspace.clear();
          // Blockly.Xml.domToWorkspace(xmlDom, workspace);
        }); 
      },

      hideExtraDivs: function() {},
      showExtraDivs: function() {},

      handleTab: function(evt) {
        if (this.selected === 0) {
          this.inject();
          this.showExtraDivs();
        } else {
          this.hideExtraDivs();
        }
        evt.stopPropagation(); // TODO(jstn): this doesn't stop propagation.
      },

      hideExtraDiv: function(div) {
        if (div) {
          div.style.display = 'none';
        }
      },

      showExtraDiv: function(div) {
        if (div) {
          div.style.display = '';
        }
      },

      inject: function() {
        if (!this.injected) {
          var toolbox = this.$.toolboxElement.$.toolbox;
          var blocklyDiv = this.$.blocklyDiv;
          //var workspace = Blockly.inject(blocklyDiv, {toolbox: toolbox, zoom: {
          //  controls: true,
          //  wheel: true,
          //  startScale: 1.0,
          //  maxScale: 2,
          //  minScale: 0.3,
          //  scaleSpeed: 1.2}
          // });
          //Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
          //Blockly.JavaScript.addReservedWords('highlightBlock');
          //var that = this;
          //var updateCode = function() {
          //  var code = Blockly.JavaScript.workspaceToCode(workspace);
          //  that.code = code;
          //};
          //workspace.addChangeListener(updateCode);
          //workspace.addChangeListener(function() {
          //  that.onProgramChange(that);
          //});
          //this.injected = true;
        }
      },

      onNameChange: function() {
        var that = this;
        var updateClient = new ROSLIB.Service({
          ros: ROS,
          name: '/code_it/update_program',
          serviceType: 'code_it_msgs/UpdateProgram'
        });
        var request = new ROSLIB.ServiceRequest({
          program: {
            program_id: that.programId,
            name: that.name,
          }
        });
        updateClient.callService(request, function(result) {
          that.program = result.program;
        }); 
      },

      onProgramChange: function(that) {
        var workspace = Blockly.getMainWorkspace();
        // var xml = Blockly.Xml.workspaceToDom(workspace);
        // var xmlText = Blockly.Xml.domToText(xml);
	var xmlText = this.myCodeMirror.getValue(); // hack to allow saving of javascript to backend 
	this.code = xmlText;
	console.log("In onProgramChange.")
	console.log("xmlText is " + xmlText);       
        var updateClient = new ROSLIB.Service({
          ros: ROS,
          name: '/code_it/update_program',
          serviceType: 'code_it_msgs/UpdateProgram'
        });
        var request = new ROSLIB.ServiceRequest({
          program: {
            program_id: this.programId,
            xml: xmlText,
          }
        });
        updateClient.callService(request, function() {}); 
      },

      _computeRunState: function(isRunning) {
        if (isRunning) {
          return 'isrunning';
        } else {
          return 'notrunning';
        }
      },

      handleRunStop: function() {
        var that = this;
        var runAction = new ROSLIB.ActionClient({
          ros: ROS,
          serverName: '/run_program',
          actionName: 'code_it_msgs/RunProgramAction'
        });
        // var workspace = Blockly.getMainWorkspace();

        if (!this.isRunning) {
          var goal = new ROSLIB.Goal({
            actionClient: runAction,
            goalMessage: {
              program: that.code
            }
          });

          goal.on('feedback', function(feedback) {
            // Turn traceOn for every feedback message. Blockly turns tracing
            // (and therefore highlighting) whenever the workspace is dragged.
          //  workspace.traceOn(true);
           // workspace.highlightBlock(feedback.block_id);
          });
          // RunProgramAction doesn't have a result yet.
          //goal.on('result', function(result) {
          //});

          goal.send();
          console.log('Running program: ' + that.code);
        } else {
          runAction.cancel();
        }
      },
    });
  })();
  </script>
</dom-module>


